# 1. OWASP (Open Web Application Security Project) Cheat Sheets — це короткі та зручні рекомендації, які допомагають розробникам та спеціалістам з безпеки краще захищати веб-додатки. Вони створені для того, щоб забезпечити чіткі, практичні кроки для впровадження різних аспектів безпеки, таких як аутентифікація, авторизація, шифрування даних, захист від SQL-ін’єкцій, захист від XSS (міжсайтового скриптингу), налаштування безпечного передавання файлів тощо.

Кожна cheat sheet зосереджується на конкретній темі та надає рекомендації, приклади коду і пояснення щодо того, як реалізувати захист, уникаючи типових помилок. Наприклад:

Authentication Cheat Sheet – рекомендації щодо безпечної реалізації аутентифікації користувачів.
SQL Injection Prevention Cheat Sheet – захист від SQL-ін’єкцій.
XSS Prevention Cheat Sheet – методи запобігання міжсайтовому скриптингу.
OWASP Cheat Sheets допомагають швидко отримати конкретні поради з безпеки без необхідності переглядати довгі документації. Вони доступні на сайті OWASP і є відкритим ресурсом для спеціалістів із безпеки.



# 2. MPurify — це бібліотека JavaScript, яка забезпечує захист від міжсайтового скриптингу (XSS) шляхом «очищення» HTML-контенту, який може містити шкідливий код. Вона особливо корисна в веб-додатках, де потрібно відображати HTML, отриманий від користувача або з неперевірених джерел.

DOMPurify працює, очищуючи HTML, видаляючи небезпечні теги та атрибути, які можуть бути використані для виконання шкідливих скриптів. Наприклад, DOMPurify видаляє <script>, подібні до нього теги, та інші потенційно небезпечні атрибути (наприклад, onload, onclick тощо), що запобігає можливим XSS-атакам.

Основні переваги DOMPurify:

Простий у використанні: легкий API, який дозволяє швидко очищати HTML.
Гнучкість: можна налаштовувати рівень очищення, включати або виключати певні теги та атрибути.
Швидкодія: працює швидко і підходить для використання в реальному часі.
Висока безпека: бібліотека постійно оновлюється відповідно до сучасних вимог безпеки та підтримує нові методи захисту від XSS.



# 3. XSS (Cross-Site Scripting)
XSS — це тип вразливості, який дозволяє зловмиснику вставляти шкідливий код (зазвичай JavaScript) на веб-сторінку, яку переглядає інший користувач. Цей код може виконувати різні небезпечні дії, як-от викрадення даних користувача, сесійних токенів, зміна відображуваного контенту тощо.

Типи XSS:
Stored XSS (збережений): шкідливий код зберігається на сервері (наприклад, у базі даних) і виводиться на сторінку кожного разу, коли її відкриває користувач.
Reflected XSS (відображений): код відображається на сторінці одразу після відправлення користувачем запиту, зазвичай через URL або форми.
DOM-based XSS: атака, коли шкідливий код обробляється безпосередньо в DOM браузера через JavaScript.
Як запобігти XSS:
Валідація та очищення введених даних за допомогою бібліотек, як-от DOMPurify.
Ескейпінг спеціальних символів у HTML, JavaScript, CSS.
Встановлення Content Security Policy (CSP) — дозволяє вказувати, з яких джерел можна виконувати JavaScript та інші ресурси.




# 4. CORS (Cross-Origin Resource Sharing)
CORS — це механізм, який браузери використовують для обмеження доступу до ресурсів, коли веб-сторінка намагається зробити запит до іншого домену, відмінного від того, з якого завантажена. За замовчуванням браузери блокують такі запити через політику Same-Origin Policy.

CORS дозволяє серверам вказувати, які домени мають право доступу до їхніх ресурсів, налаштовуючи заголовок Access-Control-Allow-Origin. Наприклад, якщо додаток https://example.com хоче отримати доступ до ресурсів на https://api.example.com, сервер api.example.com повинен дозволити цей запит, відповівши з відповідним заголовком.

Як запобігти проблемам із CORS:
  - Налаштуйте сервер так, щоб дозволити доступ тільки для надійних доменів.
  - Використовуйте механізми аутентифікації та авторизації для запитів з іншого джерела.
  - Уникайте надто загального налаштування Access-Control-Allow-Origin: *, яке дозволяє доступ з будь-якого домену.



# 5. CommonJS — це специфікація для модулів у JavaScript, яка дозволяє організувати та управляти залежностями у програмах на JavaScript. Вона найчастіше використовується в середовищах, які виконують JavaScript на сервері, таких як Node.js. Основна мета CommonJS — створити стандартизований спосіб для визначення модулів, щоб вони могли імпортувати та експортувати функціональність між файлами.

Основні принципи CommonJS
У CommonJS кожен файл є окремим модулем, і кожен модуль має свою область видимості (scope). Це дозволяє уникнути конфліктів між змінними та функціями з різних файлів.


Основні методи:

  - module.exports: використовується для експорту об'єктів, функцій або значень з модуля, щоб їх можна було використовувати в інших файлах.

  - require(): використовується для імпортування функціональності з інших модулів у поточний файл.

Особливості CommonJS
Синхронність: CommonJS використовує синхронний імпорт, що підходить для середовищ, де доступ до файлової системи є швидким (як на сервері).
Кешування модулів: Якщо модуль імпортується кілька разів, Node.js кешує його після першого завантаження, тому він не завантажується повторно.
CommonJS та ES6 Modules (ECMAScript Modules)
На відміну від CommonJS, ES6 Modules (ESM) використовує асинхронний імпорт, що краще підходить для браузерів. Основні відмінності:

CommonJS використовує require() для імпорту та module.exports для експорту, тоді як ES6 Modules використовує import та export.
CommonJS підтримується у Node.js, але ESM стає стандартом для веб-додатків та нових проектів у Node.js (де є підтримка).
Сумісність між CommonJS і ESM
Node.js підтримує обидва стандарти, але є певні обмеження при їхньому змішуванні в одному проекті. Зазвичай рекомендується використовувати один стиль у всьому проекті або чітко розділяти частини, які використовують різні стандарти.




# 6. ESModules (ECMAScript Modules або просто ESM) — це офіційний стандарт модулів JavaScript, введений в ES6 (ES2015), який підтримується як у браузерах, так і в Node.js. ESM забезпечує стандартизований спосіб організації, імпорту та експорту функцій, змінних та об'єктів між файлами, що дозволяє розробникам створювати більш структуровані та розподілені програми.

Основні принципи ESModules :

  -  Синтаксис імпорту та експорту: ESM використовує ключові слова import та export для імпорту та експорту функціональності між   модулями.

  - Асинхронність: ESModules підтримують асинхронне завантаження, що важливо для продуктивності в браузерах.

  - Строгий режим за замовчуванням: Кожен ESM-модуль автоматично працює в "строгому режимі" (strict mode), що допомагає уникнути певних помилок.

  - Tree Shaking: ESM підтримує оптимізацію коду (tree shaking), видаляючи невикористані експортовані елементи під час компіляції чи обробки.


Основні елементи синтаксису ESModules
Експорт функціональності з модуля
В ESModules є два основних види експорту: іменований (named export) та експорт за замовчуванням (default export).

Іменований експорт: використовується для експорту конкретних змінних або функцій, що дозволяє експортувати кілька елементів.

javascript
Copy code
// math.js
export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}
Експорт за замовчуванням: використовується, коли модуль експортує один основний елемент.

javascript
Copy code
// calculator.js
export default function subtract(a, b) {
  return a - b;
}
Імпорт функціональності з модуля
Іменований імпорт: використовується для імпорту конкретних елементів, визначених у модулі.

javascript
Copy code
// app.js
import { add, multiply } from './math.js';
console.log(add(5, 3));        // Виведе 8
console.log(multiply(5, 3));   // Виведе 15
Імпорт за замовчуванням: імпортує елемент, експортований за замовчуванням у модулі.

javascript
Copy code
// app.js
import subtract from './calculator.js';
console.log(subtract(10, 4)); // Виведе 6
Поєднання іменованого та дефолтного імпорту:

javascript
Copy code
// app.js
import subtract, { add, multiply } from './math.js';
Імпорт усіх елементів з модуля як об'єкт:

javascript
Copy code
import * as math from './math.js';
console.log(math.add(5, 3));   // Виведе 8
console.log(math.multiply(5, 3)); // Виведе 15
Особливості ESModules в браузері та Node.js
Браузери: Для використання модулів у браузерах можна додати атрибут type="module" до тега <script>.

html
Copy code
<script type="module" src="app.js"></script>
Node.js: Node.js з версії 12 підтримує ESM нативно. Щоб використовувати модулі, потрібно:

Зберігати файли з розширенням .mjs, або
Додати "type": "module" у package.json, якщо використовуєте .js.

Порівняння ESModules і CommonJS
Особливість	ESModules	CommonJS
Синтаксис	import/export	require()/module.exports
Асинхронність	Підтримується	Не підтримується
Tree Shaking	Підтримується	Не підтримується
Браузери	Підтримується	Не підтримується без транспіляції
Кешування модулів	Так	Так
ESModules стають стандартом для JavaScript, особливо для веб-розробки, оскільки вони підтримуються всіма сучасними браузерами і вважаються більш продуктивними та оптимізованими.



# 7. Event Loop — це механізм, що дозволяє JavaScript виконувати асинхронні операції та не блокувати основний потік виконання коду. Завдяки event loop, JavaScript може обробляти одночасно кілька операцій, хоча він працює в одному потоці. Це є основою для асинхронної обробки даних у JavaScript, особливо в середовищах, як-от браузери та Node.js.

Як працює Event Loop
Щоб зрозуміти роботу event loop, важливо знати три основні компоненти:

Call Stack (Стек викликів): використовується для зберігання функцій, які JavaScript виконує зараз або має виконати. Кожен раз, коли викликається нова функція, вона додається в стек, і коли функція завершена, вона видаляється зі стека.

Web APIs (API браузера або Node.js API): асинхронні операції, як-от таймери (setTimeout), запити (fetch, XMLHttpRequest), або робота з файловою системою, виконуються не в основному потоці JavaScript, а через відповідні API, які працюють поза call stack.

Callback Queue (Черга зворотних викликів): коли асинхронна операція завершується (наприклад, таймер або запит до сервера), її зворотний виклик (callback) додається в чергу зворотних викликів для подальшого виконання.

Процес Event Loop
Виконання в Call Stack: JavaScript виконує всі функції, що знаходяться в стеку викликів. Якщо стек порожній, event loop перевіряє чергу зворотних викликів.

Переміщення callback з черги в стек: Якщо в черзі є callback-функції, event loop переміщує їх у стек викликів, де вони виконуються. Це відбувається лише тоді, коли стек викликів порожній, тобто JavaScript закінчив виконання всіх синхронних операцій.

Черги та Пріоритети :
  - Macro Task Queue: використовується для таймерів (setTimeout, setInterval), обробників подій та інших великих завдань.

  - Micro Task Queue: використовується для обробки зворотних викликів Promise та process.nextTick() (в Node.js). Завдання з цієї черги 
  виконуються перед тим, як event loop перейде до черги зворотних викликів.

Event loop обробляє microtasks, а потім переходить до наступної macro task, що допомагає керувати чергами в JavaScript.




# 8. Рендерінг (Rendering) — це процес перетворення коду візуальної частини веб-додатка (HTML, CSS, JavaScript) у видимий контент на екрані користувача. У веб-розробці рендерінг — це етап, коли браузер обробляє і відображає структуру, стилі та динамічні елементи веб-сторінки, перетворюючи їх у фінальний вигляд для користувача.

Як відбувається рендерінг у браузері
Завантаження та обробка HTML: Браузер завантажує HTML-документ і починає його аналізувати (парсити). На цьому етапі створюється DOM (Document Object Model) — об'єктне представлення структури документа.

Завантаження та обробка CSS: CSS-файли також завантажуються і обробляються для створення CSSOM (CSS Object Model) — об'єкта, який містить усі стилі для кожного елемента на сторінці.

Комбінування DOM і CSSOM: DOM та CSSOM об'єднуються для створення рендер-дерева (render tree), яке включає елементи сторінки з усіма стилями, необхідними для їх відображення. У render tree не включаються невидимі елементи (наприклад, display: none).

Розмітка (Layout): На цьому етапі браузер розраховує розташування кожного елемента на сторінці на основі render tree. Визначаються розміри, позиції та відступи кожного елемента.

Рендерінг (Painting): Браузер малює (рендерить) кожен елемент на екрані відповідно до його розташування і стилів. Це останній етап, коли вміст сторінки стає видимим для користувача.

Типи рендерінгу
Клієнтський рендерінг (Client-Side Rendering, CSR): Обробка HTML і JavaScript відбувається на стороні клієнта (в браузері). Це часто використовується в SPA (Single-Page Applications) з використанням фреймворків, як-от React, Angular, Vue.js. Початковий HTML може бути мінімальним, а вся логіка і контент завантажуються через JavaScript. Це забезпечує динамічність і інтерактивність, але початкове завантаження сторінки може бути повільним через великі обсяги JavaScript.

Серверний рендерінг (Server-Side Rendering, SSR): Весь HTML формується на сервері й відправляється браузеру у вже обробленому вигляді. Це забезпечує швидкий початковий рендерінг, що корисно для SEO і зменшує час першого відображення сторінки.

Гібридний рендерінг (Static-Site Generation, SSG, або гібрид CSR і SSR): Частина сторінок генерується заздалегідь на сервері (статично) і завантажується швидше, а решта контенту може бути завантажена динамічно на стороні клієнта. Це підхід використовується в сучасних фреймворках, таких як Next.js.

Чому рендерінг важливий?
Рендерінг безпосередньо впливає на швидкість завантаження сторінок, користувацький досвід і SEO (оптимізацію під пошукові системи). Швидкий і ефективний рендерінг забезпечує краще відображення контенту, особливо на мобільних пристроях, де ресурси обмежені.

Оптимізація процесу рендерінгу — один із важливих етапів для створення швидких, адаптивних і доступних веб-додатків.

