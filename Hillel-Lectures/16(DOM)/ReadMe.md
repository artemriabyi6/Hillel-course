# 1. У JavaScript модуль — це окремий файл або частина коду, що експортує певний функціонал (функції, змінні, класи) і може імпортуватися в інші частини програми. Модулі дозволяють структурувати код, розділяючи його на логічні частини, що підвищує зручність розробки, читабельність і підтримку проєкту.

Основні особливості модулів в JavaScript:
Експорт та імпорт:

Елементи (функції, об'єкти, класи) можна експортувати з одного модуля та імпортувати їх в інший.
Для експорту використовують ключові слова export або export default.
Імпортують за допомогою import.
Типи експорту:

Іменований експорт (export): дозволяє експортувати кілька елементів з модуля.
Експорт за замовчуванням (export default): дозволяє експортувати один основний елемент з модуля.



# 2. Різниця між файлом і модулем у JavaScript полягає в наступному:

Файл:

Файл — це фізична одиниця зберігання даних на диску, яка містить текстовий або інший тип даних.
У контексті JavaScript файл може містити будь-який код, але якщо він не експортує та не імпортує жодного функціоналу, то він не вважається модулем.
Наприклад, файл script.js може містити JavaScript-код, який просто виконується при завантаженні, але без підтримки імпорту та експорту.
Модуль:

Модуль — це логічна одиниця коду, яка структурно організована для повторного використання. Модуль експортує певний функціонал (змінні, функції, класи) та може імпортувати функціонал з інших модулів.
Файл стає модулем, якщо в ньому використовується export для передачі даних іншим модулям або import для отримання даних з них.
Наприклад, файл math.js стає модулем, якщо в ньому визначено функції або змінні, які експортуються для використання в інших файлах.
Підсумок
Файл — це одиниця зберігання даних.
Модуль — це файл JavaScript, який використовує механізми export та import для обміну функціоналом з іншими файлами.
Таким чином, будь-який модуль є файлом, але не кожен файл є модулем.



# 3. Деструктуризація в JavaScript — це спосіб витягувати значення з масивів або об'єктів і зберігати їх у змінні, використовуючи зручний синтаксис. Це дозволяє скоротити код і зробити його більш читабельним.

Деструктуризація масивів
Деструктуризація масиву дозволяє зручно присвоїти значення елементів масиву окремим змінним.

Приклад:
javascript
Copy code
const numbers = [1, 2, 3];
const [first, second, third] = numbers;

console.log(first);  // 1
console.log(second); // 2
console.log(third);  // 3
Пропуск елементів:
Можна пропустити значення в масиві, залишивши порожні коми.

javascript
Copy code
const numbers = [1, 2, 3, 4];
const [first, , third] = numbers;

console.log(first);  // 1
console.log(third);  // 3
Значення за замовчуванням:
Якщо значення не існує, можна задати значення за замовчуванням.

javascript
Copy code
const numbers = [1];
const [first, second = 5] = numbers;

console.log(first);  // 1
console.log(second); // 5
Деструктуризація об'єктів
Деструктуризація об'єкта дозволяє присвоїти значення властивостей об'єкта змінним з такими ж іменами.

Приклад:
javascript
Copy code
const user = { name: 'Alice', age: 25 };
const { name, age } = user;

console.log(name); // "Alice"
console.log(age);  // 25
Зміна імен змінних:
Можна задати інші імена змінним під час деструктуризації.

javascript
Copy code
const user = { name: 'Alice', age: 25 };
const { name: userName, age: userAge } = user;

console.log(userName); // "Alice"
console.log(userAge);  // 25
Значення за замовчуванням:
Якщо властивості немає в об'єкті, можна задати значення за замовчуванням.

javascript
Copy code
const user = { name: 'Alice' };
const { name, age = 30 } = user;

console.log(name); // "Alice"
console.log(age);  // 30
Вкладена деструктуризація
Деструктуризацію можна застосовувати до вкладених об'єктів та масивів.

Приклад:
javascript
Copy code
const person = {
  name: 'Alice',
  address: {
    city: 'Wonderland',
    zip: 12345
  }
};

const {
  name,
  address: { city, zip }
} = person;

console.log(name); // "Alice"
console.log(city); // "Wonderland"
console.log(zip);  // 12345
Використання деструктуризації в функціях
Деструктуризацію часто використовують для параметрів функцій, особливо коли передаються об'єкти з багатьма властивостями.

Приклад:
javascript
Copy code
function greet({ name, age }) {
  console.log(`Hello, ${name}! You are ${age} years old.`);
}

const user = { name: 'Alice', age: 25 };
greet(user); // "Hello, Alice! You are 25 years old."
Переваги деструктуризації
Коротший код: скорочує код, роблячи його більш компактним і зручним для читання.
Зручність доступу: дозволяє швидко витягати дані з об'єктів і масивів без зайвих звернень до властивостей чи індексів.
Деструктуризація — це потужний інструмент, який робить код більш зрозумілим і зручним.




# 4. Динамічні імпорти в JavaScript дозволяють завантажувати модулі асинхронно під час виконання програми, а не на початку, як у випадку з традиційними статичними імпортами (import). Це корисно для оптимізації продуктивності та дозволяє завантажувати тільки ті модулі, які необхідні в певний момент.

Як працюють динамічні імпорти
Динамічні імпорти використовують функцію import(), яка повертає обіцянку (Promise). Коли модуль завантажений, обіцянка виконується і повертає експортовані елементи модуля. Такий підхід дозволяє імпортувати модулі умовно або в момент, коли вони дійсно потрібні.

Синтаксис
javascript
Copy code
import('./path/to/module.js')
  .then(module => {
    // Використовуємо імпортовані елементи з модуля
    module.default();
  })
  .catch(error => {
    console.error("Помилка при завантаженні модуля:", error);
  });
Приклад використання динамічного імпорту
javascript
Copy code
function loadModule() {
  import('./math.js')
    .then(math => {
      console.log(math.add(2, 3));  // Припустимо, math.js експортує функцію add
    })
    .catch(error => {
      console.error("Не вдалося завантажити модуль:", error);
    });
}
Приклад із використанням async/await
Динамічний імпорт можна також використовувати з async/await для зручнішого асинхронного коду.

javascript
Copy code
async function loadModule() {
  try {
    const math = await import('./math.js');
    console.log(math.add(2, 3)); // 5
  } catch (error) {
    console.error("Не вдалося завантажити модуль:", error);
  }
}
Переваги динамічних імпортів
Оптимізація продуктивності: дозволяє завантажувати код частинами (lazy-loading), що зменшує розмір початкового завантаження програми.
Кращий користувацький досвід: сторінка завантажується швидше, а додатковий функціонал завантажується тільки тоді, коли він потрібен.
Умовне завантаження: можна імпортувати модулі на основі умов, що дозволяє реалізувати функціонал тільки для певних сценаріїв.
Коли використовувати динамічні імпорти
Lazy-loading (відкладене завантаження) важких бібліотек або модулів.
Коли модуль використовується тільки у певних випадках або за певних умов (наприклад, компоненти, що завантажуються тільки за запитом).
Для покращення швидкості завантаження та оптимізації розподілу ресурсів.
Динамічні імпорти стали доступні в стандарті ECMAScript 2018 (ES9) і підтримуються більшістю сучасних браузерів, а також Node.js.




# 5. У консолі розробника браузера (наприклад, Chrome DevTools) є багато корисних шорткатів і команд для швидкої роботи. Ось деякі з них:

__Спеціальні змінні:__

  - $0, $1, $2, $3, $4 — посилаються на останні п’ять вибраних елементів у вкладці Elements.

  - $_ — результат останнього виразу, який виконувався в консолі.

  - $ — виконує document.querySelector, тобто $('selector') рівнозначне document.querySelector('selector').

  - $$ — виконує document.querySelectorAll і повертає масив усіх знайдених елементів: $$('selector').

  - dir() — відображає об’єкт як JavaScript-об'єкт (а не як DOM-елемент). Наприклад, dir($0) показує всі властивості обраного елемента.


__Команди для таймерів і відстеження:__

  -  console.time('label') і console.timeEnd('label') — вимірюють час виконання коду між цими двома командами.

  - console.trace() — виводить стек викликів, що допомагає відстежити, звідки викликалася функція.

  - monitor(functionName) і unmonitor(functionName) — дозволяють моніторити виклики певної функції. Після monitor(funcName) у консолі буде виведено кожен виклик цієї функції.

  - debug(functionName) — встановлює точку зупинки на початку виконання зазначеної функції, що зручно для налагодження.

__Команди для роботи з пам’яттю:__

  - performance.memory — надає інформацію про використання пам’яті (в основному для додатків, що працюють із великими даними або складними об’єктами).
  
  - console.memory — виводить статистику використання пам'яті (доступно не у всіх браузерах).

__Робота з логами та повідомленнями:__

  - console.log() — стандартний лог для виведення інформації.
  
  - console.warn() — виводить повідомлення з позначкою попередження.
  
  - console.error() — виводить повідомлення з позначкою помилки.
  
  - console.group(), console.groupEnd() — групує кілька логів у collapsible-структуру для зручності перегляду.
  
  - console.table() — виводить дані у вигляді таблиці, що зручно для роботи з масивами об'єктів або з великими наборами даних.

__Навігація в DevTools:__

  - Ctrl + L (Windows) або Cmd + K (Mac) — очищує консоль.

  - Ctrl + [ та Ctrl + ] (або Cmd на Mac) — переходить між вкладками в DevTools (Elements, Console, Sources тощо).
  
  - Alt + стрілка вгору/вниз — навігація по історії команд, виконаних у консолі.

__Зміна стилів у реальному часі:__

  - copy() — копіює текст або об’єкт у буфер обміну. Наприклад, copy($0) скопіює HTML-елемент у буфер.

  - inspect(element) — відкриває інспектор елементів для вказаного елемента.




# 6. Web APIs — це інтерфейси, надані браузерами та середовищами виконання (як-от Node.js), що дозволяють взаємодіяти з різноманітними веб-ресурсами та функціями. Вони значно розширюють можливості JavaScript, забезпечуючи доступ до різних функціональностей, таких як мережеві запити, робота з DOM, обробка графіки, доступ до геолокації тощо.

Ось деякі основні та популярні Web APIs:

__1. DOM API (Document Object Model)__
Використовується для маніпуляції структурою HTML-документа, CSS і подіями.
Дозволяє змінювати елементи, атрибути та вміст веб-сторінки.
Приклади: document.getElementById(), element.addEventListener(), document.createElement().


__2. Fetch API__
Забезпечує сучасний спосіб виконання HTTP-запитів для отримання ресурсів із сервера.
fetch() повертає обіцянку (Promise), яка виконується, коли запит завершується.
Підтримує методи запитів (GET, POST тощо) та обробку JSON-відповідей.

Приклад:
javascript
Copy code
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));


__3. Canvas API__
Дає можливість малювати графіку, діаграми та анімації за допомогою тегу <canvas>.
Забезпечує 2D-контекст для малювання форм, зображень, тексту тощо.

Приклад:
javascript
Copy code
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'blue';
ctx.fillRect(10, 10, 100, 100);



__4. Geolocation API__
Дозволяє отримати поточне місцезнаходження користувача (з дозволу користувача).
Використовується для додатків, що вимагають геолокації (карти, рекомендації тощо).

Приклад:
javascript
Copy code
navigator.geolocation.getCurrentPosition(position => {
  console.log(position.coords.latitude, position.coords.longitude);
});



__5. Storage APIs (LocalStorage та SessionStorage)__
Дозволяють зберігати дані на стороні клієнта у браузері.
LocalStorage зберігає дані без терміну придатності, SessionStorage — лише на час поточної сесії.

Приклад:
javascript
Copy code
localStorage.setItem('username', 'Alice');
const username = localStorage.getItem('username');



__6. WebSockets API__
Дозволяє встановити двостороннє з'єднання між клієнтом і сервером для обміну даними в реальному часі.
Використовується для чатів, сповіщень і всіх випадків, де потрібна швидка передача даних.

Приклад:
javascript
Copy code
const socket = new WebSocket('wss://example.com/socket');
socket.onmessage = (event) => {
  console.log('Message from server', event.data);
};



__7. Notification API__
Дає можливість показувати нативні сповіщення користувачу.
Потребує дозволу від користувача для відображення сповіщень.

Приклад:
javascript
Copy code
if (Notification.permission === 'granted') {
  new Notification('Hello, world!');
}



__8. File API__
Дозволяє взаємодіяти з файлами на пристрої користувача, наприклад, завантажувати файли або зчитувати їх вміст.
Використовується для завантаження файлів у форми, обробки зображень тощо.

Приклад:
javascript
Copy code
const input = document.querySelector('input[type="file"]');
input.addEventListener('change', () => {
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = () => {
    console.log(reader.result);
  };
  reader.readAsText(file);
});



__9. Web Workers API__
Дозволяє запускати JavaScript-код у фонових потоках, щоб не блокувати основний потік (інтерфейс).
Використовується для тривалих обчислень або завдань, що вимагають багато ресурсів.

Приклад:
javascript
Copy code
const worker = new Worker('worker.js');
worker.postMessage('Hello');
worker.onmessage = (event) => {
  console.log(event.data);
};


__10. History API__
Дає можливість керувати історією переглядів у браузері (корисно для SPA).
Використовується для зміни URL без перезавантаження сторінки.

Приклад:
javascript
Copy code
history.pushState({page: 1}, 'Title', '/new-url');
Web APIs дозволяють створювати потужні веб-додатки, що взаємодіють із користувачем на глибшому рівні, та розширюють можливості роботи з браузером та іншими середовищами.




# 7. Set, Map, WeakSet, і WeakMap — це спеціальні структури даних у JavaScript, які дозволяють зберігати унікальні значення або пари ключ-значення. Вони відрізняються від традиційних масивів і об'єктів своїми особливими властивостями.

Ось детальний огляд кожної з них:

__1. Set__
Зберігає унікальні значення будь-якого типу (примітиви та об'єкти).
Не допускає дублювання елементів.
Вміщує методи для додавання, видалення і перевірки наявності значень.
Приклад:
javascript
Copy code
const set = new Set();
set.add(1);
set.add(2);
set.add(2); // Дубльовані значення ігноруються

console.log(set); // Set(2) {1, 2}
console.log(set.has(1)); // true
set.delete(1);
console.log(set.has(1)); // false



__2. Map__
Зберігає пари ключ-значення, де будь-яке значення може бути ключем (не тільки рядки, як у звичайних об’єктах).
Ключі можуть бути будь-якого типу: примітиви, об'єкти, функції тощо.
Зберігає порядок додавання пар ключ-значення.
Приклад:
javascript
Copy code
const map = new Map();
map.set('name', 'Alice');
map.set(10, 'age');

console.log(map.get('name')); // Alice
console.log(map.has(10)); // true
map.delete(10);
console.log(map.has(10)); // false




__3. WeakSet__
Зберігає тільки об'єкти (не може містити примітиви).
Об'єкти в WeakSet мають слабке посилання (weak reference). Якщо об'єкт більше не має інших посилань, він буде видалений з пам'яті (garbage collection).
WeakSet не підтримує ітерацію, тобто не можна отримати всі елементи в колекції, як у Set.

Приклад:
javascript
Copy code
const weakSet = new WeakSet();
let obj = {name: 'Alice'};
weakSet.add(obj);

console.log(weakSet.has(obj)); // true
obj = null; // Об'єкт видаляється з пам'яті автоматично
console.log(weakSet.has(obj)); // false



__4. WeakMap__
Зберігає пари ключ-значення, де ключем може бути тільки об'єкт (примітиви як ключі не допускаються).
Ключі мають слабке посилання, тому коли об'єкт, що використовується як ключ, видаляється з пам'яті, запис у WeakMap теж автоматично видаляється.
Не підтримує ітерацію або отримання розміру колекції.

Приклад:
javascript
Copy code
const weakMap = new WeakMap();
let obj = { id: 1 };
weakMap.set(obj, 'User data');

console.log(weakMap.get(obj)); // User data
obj = null; // Об'єкт видаляється з пам'яті разом із записом у WeakMap
console.log(weakMap.get(obj)); // undefined
Відмінності між Set, Map, WeakSet і WeakMap
Особливість	Set	Map	WeakSet	WeakMap
Тип даних	Будь-який тип	Будь-який тип	Тільки об'єкти	Тільки об'єкти
Унікальність значень	Так	Ні	Так	Ні
Підтримка ітерації	Так	Так	Ні	Ні
Автоматичне видалення	Ні	Ні	Так (об'єкти)	Так (ключі-об'єкти)
Підрахунок розміру	size	size	Немає доступу	Немає доступу


Використання:

__Set — коли потрібен набір унікальних значень, як-от теги, категорії.__


__Map — для зберігання пар ключ-значення, особливо якщо ключі можуть бути різних типів.__


__WeakSet — для зберігання унікальних об’єктів із автоматичним видаленням (наприклад, кешування).__


__WeakMap — для асоціації даних з об’єктами та автоматичного видалення даних, коли об’єкт видаляється (наприклад, для зберігання метаданих про об’єкти).__





